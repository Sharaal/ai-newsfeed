{
  "request": {
    "output": {
      "type": "array",
      "schema": {
        "type": "array",
        "items": {
          "type": "object",
          "required": [
            "name",
            "relevance"
          ],
          "properties": {
            "name": {
              "type": "string"
            },
            "relevance": {
              "type": "number"
            },
            "reasoning": {
              "type": "string"
            }
          }
        }
      }
    },
    "prompt": "\nDu bist ein technischer News-Kategorisierungsassistent mit Fachkenntnissen in IT, Künstlicher Intelligenz, Programmierung, Datenbanken, Arbeitswelt und rechtlichen Themen.\nDeine Aufgabe ist es, einen gegebenen Newstext den passenden Kategorien zuzuordnen und für jede Kategorie eine Relevanz zwischen 1 (nur für Spezialinteressierte) und 10 (bahnbrechend, für alle relevant) zu vergeben.\n\nDie Kategorien werden dir als Markdown-Liste vorgegeben.\nGehe folgendermaßen vor:\n1. Analysiere den Newstext.\n2. Wähle alle passenden Kategorien.\n3. Vergib für jede gewählte Kategorie eine Relevanz von 1 bis 10 und begründe deine Einstufung in einem Satz.\n\nHier ist die Kategorien-Liste:\n- ai\n- programming\n- databases\n- security\n- work\n- data protection\n- copyright\n\nHier ist der Newstext:\n# Write async code in JavaScript\n\n\nIn a past article I described the [async behavior in JavaScript](/2018/01/25/async-behavior-in-javascript.html). To write async code there are a lot of different options and every few months it switches to another. That results in every new project use another, or even worse every part of one project.\n\n<!--more-->\n\nSo I give here a small overview over the different options with their pros and cons.\n\n## Callbacks\n\nCallbacks are functions which we hand over to another functions which calls them immediately after some blocking operations (sync) or at the end of the event loop, maybe not until an event is triggered (async).\n\nIn JavaScript its a common behavior a callback gets called not only if something is finished successfully, also if some\nerror happens to give the possibility to handle that error. Because of this its common a callback function gets the\nerror as first parameter, which needs to be checked.\n\n```javascript\ndoSomething((err, data) => {\n  if (err) {\n    console.log('doSomething finished with an error');\n    return;\n  }\n  console.log('doSomething is successfully finished');\n});\n```\n\nPros:\n\n* Easy to use in easy scenarios\n\nCons:\n\n* Errors must be handled in every callback function\n* The parameters of a callback are only by convention error and data, not all callbacks rely on that\n* Gets really fast unreadable in nested scenarios (naming \"callback hell\"):\n\n```javascript\ndoSomething((err, data) => {\n  if (err) {\n    console.log('First doSomething finished with an error');\n    return;\n  }\n  console.log('First doSomething is successfully finished');\n  doSomething((err, data) => {\n    if (err) {\n      console.log('Second doSomething finished with an error');\n      return;\n    }\n    console.log('Second doSomething is successfully finished');\n  });\n});\n```\n\n* Gets even more complicated if things should run in parallel and things should run after that:\n\n```javascript\nconst results = [];\n\ndoSomething((err, data) => {\n  if (err) {\n    console.log('One doSomething finished with an error');\n  } else {\n    console.log('One doSomething is successfully finished');\n  }\n  results.push({ err, data });\n  if (results.length === 2) {\n    console.log('Both doSomething are finished');\n  }\n});\n\ndoSomething((err, data) => {\n  if (err) {\n    console.log('One doSomething finished with an error');\n  } else {\n    console.log('One doSomething is successfully finished');\n  }\n  results.push({ err, data });\n  if (results.length === 2) {\n    console.log('Both doSomething are finished');\n  }\n});\n```\n\n## \"async\" package\n\nThe [\"async\" package](https://www.npmjs.com/package/async) solves the most problematical aspects of writing async code only with callbacks. Especially a sequence of depending async functions or parallel execution of async functions is a lot easier with it. But as it is only a wrapper around callbacks, it can not fix all the problems.\n\n```javascript\nasync.parallel([\n  doSomething,\n  doSomething,\n], function(err, results) {\n  if (err) {\n    console.log('One doSomething finished with an error');\n    return;\n  }\n  console.log('Both doSomething are successfully finished');\n});\n```\n\nPros:\n\n* Sequence and parallel executions is a lot easier\n\n## Promises\n\nPromises are a new standard to write async code. They standardize the success and failure scenario, allow easily chaining and parallelism and become better and better supported.\n\nPros:\n\n* Chain promises allows a more central error handling\n\n```javascript\ndoSomething(data)\n  .then(data => { console.log('First doSomething is successfully finished'); })\n  .then(data => doSomething(data))\n  .then(data => { console.log('Second doSomething is successfully finished'); })\n  .catch(err => { console.log('One doSomething finished with an error'); });\n```\n\n* Also parallelism are easier\n\n```javascript\nPromise.all([\n  doSomething,\n  doSomething,\n])\n  .then(data => { console.log('Both doSomething are successfully finished'); })\n  .catch(err => { console.log('One doSomething finished with an error'); });\n```\n\nCons:\n\n* Errors must be handled in every chain\n* A lot of callbacks are still in use which makes promises very verbose\n\n## \"co\" package\n\nThe [\"co\" package](https://www.npmjs.com/package/co) fits in the time niche between callbacks, promises and async/await. It wraps all async code and allows to write it in a sync way by using generator functions and `yield`. But with the support of async/await it is not anymore needed.\n\nPros:\n\n* Write async code like it would be sync code\n* Throw errors and let us use try/catch for error handling\n\nCons:\n\n* It is need to wrap a lot of code\n* Not needed anymore, use async/await\n\n## async/await keywords\n\n```javascript\ntry {\n  const data = await doSomething();\n  console.log('doSomething is successfully finished');\n} catch (e) {\n  console.log('doSomething finished with an error');\n}\n```\n\nPros:\n\n* Native keywords for flow control (if, for/while) and error handling (try/catch)\n* No boilerplate and callbacks results in compact code which can be better readable\n\nCons:\n\n* Promises are not completely abstracted (e.g. Promise.all is needed for parallelism)\n* Not all libraries (especially the Node.js standard libraries) support promises\n* It is needed to keep in mind code looks sync, but it is and behave still async\n\n    ",
    "timestamp": "2025-07-04T13:27:27.531Z"
  },
  "response": {
    "data": {
      "result": [
        {
          "role": "assistant",
          "content": [
            {
              "type": "tool-call",
              "toolCallId": "tooluse_GIpC5mtERv2iO_Tugpz-zw",
              "toolName": "web_search",
              "args": {
                "query": "JavaScript async programming callbacks promises async await 2024"
              }
            }
          ],
          "id": "9a8b3e0f-96a3-493f-9260-1484cd17358c"
        },
        {
          "role": "tool",
          "id": "d1bd88f8-a590-427a-9904-e89cce94f690",
          "content": [
            {
              "type": "tool-result",
              "toolCallId": "tooluse_GIpC5mtERv2iO_Tugpz-zw",
              "toolName": "web_search",
              "result": {
                "input": "JavaScript async programming callbacks promises async await 2024",
                "output": [
                  {
                    "title": "Asynchronous Programming in JavaScript – Callbacks, Promises, & Async ...",
                    "url": "https://www.freecodecamp.org/news/asynchronous-programming-in-javascript-examples/",
                    "type": "website-preview",
                    "text": "Asynchronous programming in JavaScript is used to make tasks in a program run concurrently and uses techniques such as callbacks, Promise, or async / await. This article explains how to use these asynchronous programming techniques and how to handle errors with them.. \n\nSearch  Submit your search query\n\n[](https://www.freecodecamp.org/news/)\n\n[Forum](https://forum.freecodecamp.org/) [Donate](https://www.freecodecamp.org/donate/)\n\nFebruary 2, 2024 / [#async/await](/news/tag/asyncawait/)\n\nAsynchronous Programming in JavaScript – Callbacks, Promises, & Async/Await Examples\n====================================================================================\n\n[Musab Habeeb](/news/author/Musab19/)\n\n \n\nAll programming languages have runtime engines that execute their code. In JavaScript, the runtime engine is single-threaded, which means that it runs code line by line or sequentially.\n\nThe JavaScript runtime engine makes it a synchronous programming language where programs run sequentially. Programming languages that are not synchronous are called asynchronous programming languages, which are programming languages where programs run concurrently.\n\nAlthough JavaScript is synchronous, you can perform asynchronous programming with it. In this article, you will learn about asynchronous programming in JavaScript and how to use it.\n\nWhat is Asynchronous Programming?\n---------------------------------\n\nAsynchronous programming is a technique that allows your program to run its tasks concurrently. You can compare asynchronous programming to a chef with multiple cookers, pots, and kitchen utensils. This chef will be able to cook various dishes at a time.\n\nAsynchronous programming makes your JavaScript programs run faster, and you can perform asynchronous programming with any of these:\n\n*   Callbacks\n    \n*   Promises\n    \n*   Async/Await\n    \n\nIn the upcoming sections, you will learn about these techniques and how to use them.\n\nCallbacks\n---------\n\nA callback is a function used as an argument in another function. Callbacks allow you to create asynchronous programs in JavaScript by passing the result of a function into another function.\n\n    function greet(name) {\n        console.log(`Hi ${name}, how do you do?`);\n    }\n    \n    function displayGreeting(callback) {\n        let name = prompt(\"Please enter your name\");\n        callback(name);\n    };\n    \n    displayGreeting(greet);\n    \n\nIn the code above, the `greet` function is used to log a greeting to the console, and it needs the name of the person to be greeted.\n\nThe `displayGreeting` function gets the person's name and has a callback that passes the name as an argument to the `greet` function while calling it. Then the `displayGreeting` function is called with the greet function passed to it as an argument.\n\n### Callback hell\n\nAlthough callbacks make it easy to control and make your program asynchronous, you'll eventually run into a problem called callback hell while using them.\n\nThis problem arises when you perform multiple asynchronous tasks with callbacks, which might result in nesting callbacks in callbacks.\n\nHere's an example:\n\n    function greet(callback) {\n        setTimeout(function() {\n            console.log(\"Hi Musab\");\n            callback();\n        }, 1000);\n    }\n    \n    function introduce(callback) {\n        setTimeout(function() {\n            console.log(\"I am your academic advisor\");\n            callback();\n        }, 1000);\n    }\n    \n    function question(callback) {\n        setTimeout(function() {\n            console.log(\"Are you currently facing any challenge in your academics\");;\n            callback();\n        }, 1000);\n    }\n    \n    // callback hell\n    greet(function() {\n        introduce(function() {\n            question(function() {\n                console.log(\"Done\");\n            });\n        });\n    });\n    \n\nIn the code above, the `greet`, `introduce`, and `question` functions are nested to create a callback hell, which makes error handling difficult. You should change your asynchronous programming technique from callbacks to `Promise` to avoid the callback hell.\n\nPromise\n-------\n\nMost programs consist of a producing code that performs a time-consuming task and a consuming code that needs the result of the producing code.\n\nA `Promise` links the producing and the consuming code together. In the example below, the `displayGreeting` function is the producing code while the `greet` function is the consuming code.\n\n    let name;\n    \n    // producing code\n    function displayGreeting(callback) {\n        name = prompt(\"Please enter your name\");\n    }\n    \n    // consuming code\n    function greet(name) {\n        console.log(`Hi ${name}, how do you do?`);\n    }\n    \n\nIn the example below, the `new Promise` syntax creates a new `Promise`, which takes a function that executes the producing code. The function either resolves or rejects its task and assigns the `Promise` to a variable named `promise`.\n\nIf the producing code resolves, its result will ",
                    "idx": "2-0"
                  },
                  {
                    "title": "Callbacks vs Promises vs Async/Await - GeeksforGeeks",
                    "url": "https://www.geeksforgeeks.org/javascript/callbacks-vs-promises-vs-async-await/",
                    "type": "website-preview",
                    "text": "JavaScript provides three main ways to manage asynchronous tasks: Callbacks: The traditional approach using functions passed as arguments. Promises: A better alternative that improves readability and avoids callback nesting. Async/Await: A modern and cleaner syntax that makes asynchronous code look synchronous.. ",
                    "idx": "2-1"
                  },
                  {
                    "title": "How To Use JavaScript Promises – Callbacks, Async/Await, And Promise ...",
                    "url": "https://expertbeacon.com/how-to-use-javascript-promises-callbacks-async-await-and-promise-methods-explained/",
                    "type": "website-preview",
                    "text": "Promises primarily improve callbacks by handling: So promises containerize callbacks while providing sane handling for asynchrony and errors. Async/await later built on promises to enable even cleaner synchronous-style coding: try { . let posts = await fetchPosts(); renderPosts(posts); } catch (error) { showError(error);. ",
                    "idx": "2-2"
                  },
                  {
                    "title": "Promises, async/await - The Modern JavaScript Tutorial",
                    "url": "https://javascript.info/async",
                    "type": "website-preview",
                    "text": "Promises, async/await Introduction: callbacks Promise Promises chaining Error handling with promises Promise API Promisification Microtasks Async/await Ctrl + ← Ctrl + →. \n\nEN\n\n*   [ARعربي](https://ar.javascript.info/)\n*   [ENEnglish](https://javascript.info/async)\n*   [ESEspañol](https://es.javascript.info/async)\n*   [FAفارسی](https://fa.javascript.info/async)\n*   [FRFrançais](https://fr.javascript.info/async)\n*   [IDIndonesia](https://id.javascript.info/)\n\n*   [ITItaliano](https://it.javascript.info/)\n*   [JA日本語](https://ja.javascript.info/async)\n*   [KO한국어](https://ko.javascript.info/async)\n*   [RUРусский](https://learn.javascript.ru/async)\n*   [TRTürkçe](https://tr.javascript.info/)\n*   [UKУкраїнська](https://uk.javascript.info/async)\n\n*   [ZH简体中文](https://zh.javascript.info/async)\n\nWe want to make this open-source project available for people all around the world.\n\n[Help to translate](https://javascript.info/translate) the content of this tutorial to your language!\n\n[](/)\n\n[BuyEPUB/PDF](/ebook)\n\nSearch\n\nSearch\n\n[Tutorial map](/tutorial/map)\n\nLight themeDark theme\n\nShare[](https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fasync)[](https://www.facebook.com/sharer/sharer.php?s=100&p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fasync)\n\nعربيEnglishEspañolفارسیFrançaisIndonesiaItaliano日本語한국어РусскийTürkçeУкраїнська简体中文\n\n1.  [Tutorial](/)\n2.  [The JavaScript language](/js)\n\nPromises, async/await\n=====================\n\n1.  [Introduction: callbacks](/callbacks)\n2.  [Promise](/promise-basics)\n3.  [Promises chaining](/promise-chaining)\n4.  [Error handling with promises](/promise-error-handling)\n5.  [Promise API](/promise-api)\n6.  [Promisification](/promisify)\n7.  [Microtasks](/microtask-queue)\n8.  [Async/await](/async-await)\n\n[Previous lesson](/custom-errors)[Next lesson](/callbacks)\n\nShare[](https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fasync)[](https://www.facebook.com/sharer/sharer.php?s=100&p%5Burl%5D=https%3A%2F%2Fjavascript.info%2Fasync)\n\n[Tutorial map](/tutorial/map)\n\n[](/tutorial/map)\n\n#### Sibling chapters\n\n*   [An introduction](/getting-started)\n*   [JavaScript Fundamentals](/first-steps)\n*   [Code quality](/code-quality)\n*   [Objects: the basics](/object-basics)\n*   [Data types](/data-types)\n*   [Advanced working with functions](/advanced-functions)\n*   [Object properties configuration](/object-properties)\n*   [Prototypes, inheritance](/prototypes)\n*   [Classes](/classes)\n*   [Error handling](/error-handling)\n*   [Promises, async/await](/async)\n*   [Generators, advanced iteration](/generators-iterators)\n*   [Modules](/modules)\n*   [Miscellaneous](/js-misc)\n\nShare\n\n[](https://twitter.com/share?url=https%3A%2F%2Fjavascript.info%2Fasync)[](https://www.facebook.com/sharer/sharer.php?s=100&p[url]=https%3A%2F%2Fjavascript.info%2Fasync)\n\n[Edit on GitHub](https://github.com/javascript-tutorial/en.javascript.info/blob/master/1-js/11-async)\n\n*   © 2007—2025  Ilya Kantor\n*   [about the project](/about)\n*   [contact us](/about#contact-us)\n*   [terms of usage](/terms)\n*   [privacy policy](/privacy)",
                    "idx": "2-3"
                  },
                  {
                    "title": "Mastering JavaScript Asynchronous Programming: Callbacks, Promises, and ...",
                    "url": "https://medium.com/javascript-decoded-in-plain-english/mastering-javascript-asynchronous-programming-callbacks-promises-and-async-await-explained-cb93f408c79f",
                    "type": "website-preview",
                    "text": "Common methods of asynchronous programming include callback functions, Promises, and Async/Await. 1. Callback Functions. A callback function is a function passed as an argument to.... \n\n[Sitemap](/sitemap/sitemap.xml)\n\n[Open in app](https://rsci.app.link/?%24canonical_url=https%3A%2F%2Fmedium.com%2Fp%2Fcb93f408c79f&%7Efeature=LoOpenInAppButton&%7Echannel=ShowPostUnderCollection&%7Estage=mobileNavBar&source=post_page---top_nav_layout_nav-----------------------------------------)\n\nSign up\n\n[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fjavascript-decoded-in-plain-english%2Fmastering-javascript-asynchronous-programming-callbacks-promises-and-async-await-explained-cb93f408c79f&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\n\n[](/?source=post_page---top_nav_layout_nav-----------------------------------------)\n\n[\n\nWrite\n\n\n\n](/m/signin?operation=register&redirect=https%3A%2F%2Fmedium.com%2Fnew-story&source=---top_nav_layout_nav-----------------------new_post_topnav------------------)\n\n[\n\n](/search?source=post_page---top_nav_layout_nav-----------------------------------------)\n\nSign up\n\n[Sign in](/m/signin?operation=login&redirect=https%3A%2F%2Fmedium.com%2Fjavascript-decoded-in-plain-english%2Fmastering-javascript-asynchronous-programming-callbacks-promises-and-async-await-explained-cb93f408c79f&source=post_page---top_nav_layout_nav-----------------------global_nav------------------)\n\n[\n\nJS Decoded in Plain English\n\n\n-------------------------------\n\n](https://medium.com/javascript-decoded-in-plain-english?source=post_page---publication_nav-1a93d156f61b-cb93f408c79f---------------------------------------)\n\n·\n\n[\n\n](https://medium.com/javascript-decoded-in-plain-english?source=post_page---post_publication_sidebar-1a93d156f61b-cb93f408c79f---------------------------------------)\n\nJavaScript Decoded in Plain English: Dive into JavaScript like never before! We break down complex ideas into digestible bites, empowering you to master coding with confidence. Join our community and transform your coding journey today!\n\nPhoto by [Ferenc Almasi](https://unsplash.com/@flowforfrank?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)\n\nMember-only story\n\n**Mastering JavaScript Asynchronous Programming: Callbacks, Promises, and Async/Await Explained**\n=================================================================================================\n\n**A Comprehensive Guide to Understanding and Implementing Asynchronous Techniques in Modern Web Development**\n-------------------------------------------------------------------------------------------------------------\n\n[\n\n](/@jinlow?source=post_page---byline--cb93f408c79f---------------------------------------)\n\n[JIN](/@jinlow?source=post_page---byline--cb93f408c79f---------------------------------------)\n\n9 min read\n\n·\n\nNov 16, 2024\n\n[\n\n](/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Fjavascript-decoded-in-plain-english%2Fcb93f408c79f&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fjavascript-decoded-in-plain-english%2Fmastering-javascript-asynchronous-programming-callbacks-promises-and-async-await-explained-cb93f408c79f&user=JIN&userId=950e50ef0ea5&source=---header_actions--cb93f408c79f---------------------clap_footer------------------)\n\n\\--\n\n[](/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fbookmark%2Fp%2Fcb93f408c79f&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fjavascript-decoded-in-plain-english%2Fmastering-javascript-asynchronous-programming-callbacks-promises-and-async-await-explained-cb93f408c79f&source=---header_actions--cb93f408c79f---------------------bookmark_footer------------------)\n\nShare\n\n> [Thank you for being a part of this journey with me, and I hope to continue providing value to you for years to come! Giving tips by supporting me.](https://ko-fi.com/jinlowmedium)\n\nI would be overjoyed if you could support me as a [**referred member**](https://jinlow.medium.com/membership). However, the income I’ve received from my contributions on this platform has not proven sufficient to sustain the frequency of updates I’d hoped for. Facing this reality, I’ve made a difficult decision — to explore new income avenues. However, this isn’t the end; rather, it’s an exciting new beginning. I am thrilled to announce my upcoming Substack newsletter, where I’ll delve into my investing system, harnessing the immense potential of IT technology and embracing a system-thinking approach to investment strategies. Rest assured, I will still be posting when inspiration strikes.\n\n[\n\n](/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fvote%2Fjavascript-decoded-in-plain-english%2Fcb93f408c79f&operation=register&redirect=https%3A%2F%2Fmedium.com%2Fjavascript-decoded-in-plain-english%2Fmastering-javascript-asynchronous-programming-callbacks-promises-and-async-await-explained-cb93f408c79f&user=JIN&userId=950e50ef0ea5&source=---footer_action",
                    "idx": "2-4"
                  },
                  {
                    "title": "Asynchronous Programming in JavaScript: Callbacks vs Promises vs Async ...",
                    "url": "https://dev.to/itsshaikhaj/asynchronous-programming-in-javascript-callbacks-vs-promises-vs-asyncawait-690",
                    "type": "website-preview",
                    "text": "JavaScript provides three main ways to handle asynchronous operations: Callbacks, Promises, and Async/Await. In this article, we will delve into each of these methods, exploring their syntax, usage, and differences through detailed examples.. \n\n  \n\n[Skip to content](#main-content)\n\n[](/)\n\n [Powered by Algolia](https://www.algolia.com/developers/?utm_source=devto&utm_medium=referral)\n\n[Log in](https://dev.to/enter) [Create account](https://dev.to/enter?state=new-user)\n\nDEV Community\n-------------\n\nAdd reaction\n\nLike Unicorn Exploding Head Raised Hands Fire\n\nJump to Comments Save Boost\n\nModerate\n\nCopy link\n\nCopied to Clipboard\n\n[Share to X](https://twitter.com/intent/tweet?text=%22Asynchronous%20Programming%20in%20JavaScript%3A%20Callbacks%20vs%20Promises%20vs%20Async%2FAwait%22%20by%20Shaikh%20AJ%20%23DEVCommunity%20https%3A%2F%2Fdev.to%2Fitsshaikhaj%2Fasynchronous-programming-in-javascript-callbacks-vs-promises-vs-asyncawait-690) [Share to LinkedIn](https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fdev.to%2Fitsshaikhaj%2Fasynchronous-programming-in-javascript-callbacks-vs-promises-vs-asyncawait-690&title=Asynchronous%20Programming%20in%20JavaScript%3A%20Callbacks%20vs%20Promises%20vs%20Async%2FAwait&summary=Asynchronous%20programming%20is%20a%20key%20aspect%20of%20JavaScript%20that%20allows%20developers%20to%20perform%20long%20network...&source=DEV%20Community) [Share to Facebook](https://www.facebook.com/sharer.php?u=https%3A%2F%2Fdev.to%2Fitsshaikhaj%2Fasynchronous-programming-in-javascript-callbacks-vs-promises-vs-asyncawait-690) [Share to Mastodon](https://toot.kytta.dev/?text=https%3A%2F%2Fdev.to%2Fitsshaikhaj%2Fasynchronous-programming-in-javascript-callbacks-vs-promises-vs-asyncawait-690)\n\n[Report Abuse](/report-abuse)\n\n[](https://media2.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Foizubphyhyriw1vh82je.jpg)\n\n[](/itsshaikhaj)\n\n[Shaikh AJ](/itsshaikhaj)\n\nPosted on Jul 14, 2024\n\nAsynchronous Programming in JavaScript: Callbacks vs Promises vs Async/Await\n============================================================================\n\n[#webdev](/t/webdev) [#javascript](/t/javascript) [#beginners](/t/beginners) [#programming](/t/programming)\n\nAsynchronous programming is a key aspect of JavaScript that allows developers to perform long network requests, file operations, and other time-consuming tasks without blocking the main thread. This ensures that applications remain responsive and user-friendly. JavaScript provides three main ways to handle asynchronous operations: Callbacks, Promises, and Async/Await. In this article, we will delve into each of these methods, exploring their syntax, usage, and differences through detailed examples.\n\n[](#table-of-contents)Table of Contents\n---------------------------------------\n\n1.  [Introduction to Asynchronous Programming](#introduction-to-asynchronous-programming)\n2.  [Callbacks](#callbacks)\n    *   [Syntax and Example](#syntax-and-example)\n    *   [Advantages and Disadvantages](#advantages-and-disadvantages)\n3.  [Promises](#promises)\n    *   [Syntax and Example](#syntax-and-example-1)\n    *   [Chaining Promises](#chaining-promises)\n    *   [Advantages and Disadvantages](#advantages-and-disadvantages-1)\n4.  [Async/Await](#asyncawait)\n    *   [Syntax and Example](#syntax-and-example-2)\n    *   [Error Handling](#error-handling)\n    *   [Advantages and Disadvantages](#advantages-and-disadvantages-2)\n5.  [Comparison and Best Practices](#comparison-and-best-practices)\n6.  [Conclusion](#conclusion)\n\n[](#introduction-to-asynchronous-programming)Introduction to Asynchronous Programming\n-------------------------------------------------------------------------------------\n\nIn JavaScript, operations that take time to complete, such as fetching data from a server, reading files, or performing computations, can be handled asynchronously. This means that while waiting for an operation to complete, the JavaScript engine can continue executing other tasks. This is crucial for creating efficient and smooth user experiences in web applications.\n\n[](#callbacks)Callbacks\n-----------------------\n\n### [](#syntax-and-example)Syntax and Example\n\nCallbacks are one of the earliest methods for handling asynchronous operations in JavaScript. A callback is simply a function passed as an argument to another function, which will be executed once an asynchronous operation completes.  \n\n    function fetchData(callback) {\n        setTimeout(() => {\n            callback(\"Data fetched!\");\n        }, 1000);\n    }\n    \n    function displayData(data) {\n        console.log(data);\n    }\n    \n    fetchData(displayData);\n    \n\nIn the example above, `fetchData` simulates an asynchronous operation using `setTimeout`. After 1 second, it calls the `displayData` function, passing the fetched data as an argument.\n\n### [](#advantages-and-disadvantages)Advantages and Disadvantages\n\n**Advantages:**\n\n* ",
                    "idx": "2-5"
                  },
                  {
                    "title": "Asynchronous JavaScript: Callbacks, Promises, and Async/Await",
                    "url": "https://metana.io/blog/asynchronous-javascript-callbacks-promises-and-async-await/",
                    "type": "website-preview",
                    "text": "To achieve this asynchronous magic, JavaScript employs three key concepts: Callbacks, Promises, and Async/Await. Callbacks are the original way to handle asynchronous operations in JavaScript. Think of them as your juggling assistant.. ",
                    "idx": "2-6"
                  },
                  {
                    "title": "Callbacks vs. Promises vs. Async/Await: Detailed Comparison | by ...",
                    "url": "https://alek772.github.io/Articles/JavaScript%20Callbacks%20vs%20Promises%20vs%20AsyncAwait.pdf",
                    "type": "website-preview",
                    "text": "Async/await is a feature that is built on top of promises to make it better and efficient. It is more concise and provides a synchronous-like way to write asynchronous programs. await keyword is always used inside the async function scope.. \n\n%PDF-1.4 %���� 1 0 obj <> endobj 3 0 obj <> endobj 5 0 obj <> endobj 9 0 obj <> stream x�}��J�\u0014��Ԃ(��\u000e\u001d\u001c28�h��iRpi\"\u0016�V��S��A�OHS�\u0001tspu+.���c(\b\u000e��#����AR�x�������@����?��F�\u0010\\[V\\[�G@\\`\\*�\u001d\u0005dK��$���O.K\u000b\u001do�\u0002\u001f@\u0014��6\b\u001d\\`�O�,f'�˘O� \u0002a\u0012sx�0A�\u00036�\u0019vf� �8�\u0006��{c7��%op�\u0004Z�:u�\f���Q�� ��\u0014�0Q٣F \u0019\u0015\u0019�\\*\u001a��Ԑ(�S����DGACAa\u0017�j�g�rx\u0003�\u0017�\\]��s \u000f\u0017PxM�� ����c�\u001d\u0007vhO�<��v��\u0016�-X}�ţ�b3~\u0015��\\*���mDJH�T~��K� endstream endobj 8 0 obj <> stream �����ExifII\\*\b\u0005\u0012\u0001\u0003\u0001\u0001\u001a\u0001\u0005\u0001J\u001b\u0001\u0005\u0001R(\u0001\u0003\u0001\u0002i�\u0004\u0001ZH\u0001H\u0001\u0002\u0002�\u0004\u0001X\u0003�\u0004\u0001X��C\u0006\u0006\u0006\u0006\u0007\u0006\u0007\b\b\u0007 \u000b \u000b \u000f\u000e\f\f\u000e\u000f\u0016\u0010\u0011\u0010\u0011\u0010\u0016\"\u0015\u0019\u0015\u0015\u0019\u0015\"\u001e$\u001e\u001c\u001e$\u001e6\\*&&\\*6>424>LDDL\\_Z\\_||���C\u0001\u0006\u0006\u0006\u0006\u0007\u0006\u0007\b\b\u0007 \u000b \u000b \u000f\u000e\f\f\u000e\u000f\u0016\u0010\u0011\u0010\u0011\u0010\u0016\"\u0015\u0019\u0015\u0015\u0019\u0015\"\u001e$\u001e\u001c\u001e$\u001e6\\*&&\\*6>424>LDDL\\_Z\\_||���\u0011\bXX\u0003\u0001\"\u0002\u0011\u0001\u0003\u0011\u0001��\u001c\u0001\u0004\u0003\u0001\u0003\u0005\u0006\u0007\u0001\u0002\u0004\b��4\u0010\u0002\u0001\u0003\u0002\u0005\u0003\u0002\u0005\u0002\u0007\u0001\u0001\u0002\u0003\u0004\u0011\u0005!\u0006\u00121AQ\"aq\u00132\u0014����B�\u0015#3br�����\u001a\u0001\u0002\u0003\u0001\u0001\u0003\u0005\u0001\u0002\u0004\u0006��&\u0011\u0002\u0002\u0001\u0004\u0001\u0004\u0003\u0001\u0001\u0001\u0002\u0011\u0003\u0004\u0012!1A\u0005\u0013Qq\"a�R���\f\u0003\u0001\u0002\u0011\u0003\u0011?�I9��l6�+S�\u001d�P{�\u0018���L<��Y�\u0001A$� ��\u0013jrj:�HX�X��U�U�Ś��t�\b\u000f/�\u001e�=qT\f�\u0017�\u0001FI\u001c�=�~�%�\u000f�:�ŀ?\u0014�g���\u001a\u001bw��÷�,��B�%����\u0007�\u001e���ￓR� 9A c�+|�\\]\b�O��G!��%u\u0017\u0006>�k�'�Pz�ӥ� Z�s\u0010�Y�����Ģ�����$��;o���O�#\\]��\u0013I�Z�bT3 �MR'\u0004�)\u0016D>@9�z29D��\\*c�E\u000e>\u0018f�.0�=��\u0007�\u000e �>j�ᙍ�\u000fiRw6�\u000f�ڜzf\\]����.�\bÝ�ty\u0011�\u001e�(�;\fQM&x�����8��J�~)9�V6-�\u0003=)>\u0015P�Ah6ٛo'\u0019�yؒ��\u001b �͌\u001f�%�U�%@��;T\u0007V��了\u0014��C,�~�\"���흪�-�\u0004dmM\u0017v��\u0012dN�H8�qK�&�h\u0011�\u0019�N��Z\u000eT��ɢ��7I\u0010�F\\*UX��m�'�!�k�X��u(Ҝd6p��Jm���0���QmCEK��?\"�Yy�$�\u0007��u\u001bt�\u0012��}���|YF:�Aa�#����h�w-��\\`\\*A�wV�\\\\�0ȮW��9����ӣ�\u00060쿑���CS�&S��\u0004�\u000e���\u0013�^\u001d�\u0011X7, 2;\u001e�����c��\u0019\\\\�i\u0015��\u001c���ް\u000f��ݫj�F\u0004�S\u000e29�}�\u0004��EpZ�\\[^Y�um x�9����#�\u0015�r�\u000bS�W\u000f�rۓ�=�AZH��Tx�o˿��RꀬR\u001d�!'�N1X�����\u0017��7���~��\u0012M~�H�\u0011�Ba���\u0007�A�\\\\�Ȃ!\u001cg�\u0001�,{\u000fjp�%���o�;u�YNH\u0003�\\]E���\u0004�\u0013�FJ���W3���,�2�\u0010t�?ZL�}=����5�!���oC�� �\u00021\\[��h�8�\u0007ڭr\"\\`V�P�\u0018��\u001c\u0012 \\`���9\u0010���\u0004\u001e$�K\u0013�8��.n4��U��7d-�$U�07��VJ�wo\u001bC̊s�\f�\u001fڊ�-@\u0001�ܺ�\u000e�ݯ�\u000b�H�}5a�|�\f��.V4�Q\u0002���4QYG\u000eߡ'�\u001fs�G�=�A�Y\b/�ڣp�&���\u001f&�(�����Q1��\u001d(��r\"ew�Jxڊ\\*gL>Cs�;��y�~�\\`\u0004��a�|�EA�1\u0016B\u000eWu�\u0014QS:�� endstream endobj 10 0 obj <> endobj 11 0 obj <> stream x��VkTT�\u0015މIW�McURJ�Y�jh)\b\u0012� b\\*F'\u001a\u0005\u0014����\b�@@��P1��%\u0006\u0011 (�HU��\u0016�\u0006R\u0011QP\u000b\u0015\u0010�T��H\u0011\u0018�̽s;��{�a I��\u001f\\]���9������Q�M0�\u0004\u0013L0���7p\u001cGYBh��Մ\fw S��JD,(�N������@�\u0006\u000fò��\u001d�\u0006���Y\u00057���u�\u000f��z\u0018\u0011�0�i\u001b\u0011���\u0001�-xq)<�\u0006�d�ҍS\\\\C�g+^x�\u001b�\\[\u0002�j�4\f^�\u0004X\f�|��}D<�Y!��ٛ�0N6��\u0017\u0011\u001b\u001e<\u0001�=a�����0V�MK\u0007\"\u0012Bh�R>\u0017��\u0006plS��\u000b}Yd���3OJ�ɰ�}\f�������fy\u0004�y\\\\�j\u0014��X�r/���/E\u000b����(�^=�v\u001bLۄ��<�S��\u000b^�E b{w\u001f����\"�����HR�(�z� ��\u0003pH8%��{c\u0013�}Z�5\u0003\u001f)�8�\u0011\\]�#��,0�\u0012��e\u0011�\u0016\u000bv��|��\u0001�|��l\f9 \\`\u0013z�<\"Nw� �X�g���)\\`0\u0005Z;�\u0001~����h�\u0016\u0006�(�|Y�\\_��%�+���n�){�DoV��\u000b\\`���/ ���\b+f�ߪ\u001a^���+0����U\u0002�o8x���\\*\"�Eg��\u001a�� 9x��Y\u001f�b�\u001cH��z�\u001e�\u001d�)�:{a�?��\u0016\\`U�\\]ߣ0�\u001d^Yi� �\u0010���\u0007,ץ�>��g3X��-�%���>�\\_\u001a����\u0004�Fc��8\u000eGCG���\u001d�\u001f\u001e�jF\u000b�H�\u001a^�ь�h��0�A��J\u001a\u0014�W�Q�\u001d 9\\*�bn�\u0014X�FC�eI�cH\u001cc|��\u0012&ɦ�Ո�/^Bx�3\u0016dD\u001d�RQ&��<5\u001a^?Ϊ����/P\u0011°,G�V��<�(}��چ.�>��\u0004A;X�vǝ\u001daPAۯd�\u001e�\"9�$&)����Oî\f=t��\\`��}\\]ZQ\u001fw�������\u001d�S����\\*\u000b�5�g\u0010u�s����?H2\\*��\u0019�dTܑǟ��w�\\*3��(�����{,�3�\u000f�G�\u0007v�ˇ�k\u001f���9��Y�; �\\`��?\"f�O\\]\u0014l� 0.��\\\\���Qg�\u0014=���w�˴�\u0017PV��ڂ�}������\u001d�T�����\u0016��;\\[X\u0019x ;��yw����1�N\u0014����\u0018|b��>� �\u0019���d\u0011�ew���\"D�V��|�I��oT�\\]��!�O����\u0019V\u0005�k\u0010��S�\u0016��.��-����vJ��)\b\u0005am��\u000b���\u000eJ��G\u000e�\u0016�,�h�\u0014N^\u0014��V�\u0017����qmcSdbޞ���?:����vEO��\u0017�lX��x�q�6\u0004�d\u001f��O9�3�f�|�ߧ�}J�e�Կ\f���\u001a2Xp�m阿���\\]�Oۻ�b���\u0017��^�-�Qs�wXj���+|>i��yg\\[�=y�������9r��Jym@L���M\u0016�vٯ�jW�,�NX��ɮ�lD\u001ck��\u0011I�\u0019���Hɥ�/\u001d���h\\\\?���K\u001b\\*�ꇥE ё��U��|����)(�X�\u001bn{R>/1s�g�s\b�\u000f\u001ec��.F��h�\u0013$%�u:�{��.�9��%C�DB�F�\u0011�\u001aD��ʆ� ����f�����K�p�3��/k�\u0005��Z��f4&�?��s���Rl�F=�M0�\u0004\u0013L0�\u0019�\u001f��%� endstream endobj 12 0 obj <> stream x��\u0007xSe�ǟ$\\]T�=d#{ \b\u0002��\b�2\u0005�K�\u0015Eŉ\b\"���\\*�2������\fY�D��M)�M3������+V/\u0018�h�A ��\\_��k�\u001bys\u0002�\"�\u0005�B�iI\\`��X&p�������\u001e�\u001a�7 �i�\\*5䟓ڍ(Q�|=��ʺ�+)�� \\]�\u0010��|�Y)gB��ɏ���\u0010Q��Z\\]�K�x\"�����!\u0004� ���n�(�\u0018�� ��-S�5YK���A�M��LU\u0006h֩{�v�\u001c\u0015�\f\u0018���Z 6l�\u0012Ȋ%���$vEhS��;\u001b4H�zך6�\u00174����^�q���F�GhS�\u0016'����L�K�\u001a�ѹ�S\b=�\u001c)\\_���Y�͚.XRP hF.\\]\u0014�\u001b�%\u0015�\b\u0007>\u0012����|�ʋ�\u0019��\u001c�\\_�?��\bg�� ?��ۯ�\u001b\u0005�'�=�߰��)W�\\]\u0014��\\\\^��w���\"��H\u0002~t\\]\u0015�#�ߗ$NVx\"E\u0015BR51L��\u0007F\u0014�0�\\_�0l��G\ff���+�7d&����k(�Q��;��(�(��\u001aQ��+����x\"����ύ�\u001b�%��ӶxS�UUUTs�\u001bo�Y�I�LE55�߰@�@�@Q\fM�4\u0001@�����D����������x��\\]k�T��R ظ��N��U'�Q�#ѥ\u0012k7L�����\u000e\u001a\u0011\\_zD�f�=:��\u000ff\u001b\\`H�\\`�t��?獂\u0011��Q����\f�\u0019\u001c�\u0005��Jl\u0012�߿qE޸���\u0012�s� 2��\u000ezy6H��$0\u0002GI\u0002�)��I�\\*�\bo����a\\]�7.��(�5!��G���X��+�\u001bNE� �&a\u0019�?���F�Ƽa#\u0007����J�\"�\u0012���j��j����fʖ\\*�\\*\u0019��\u001a��s\u001e��K\u001bզ�H\u0014���\u001fֺ��\u0015��qۮ��vvh�箻\u0016\"佫��2e�T���r\u001b���Mm�i�WK�\u0011�d�\u0002p\u001c�����!��G\u001a�\u001b:g�J\"�Q�\u0011B�0��∦K\u0016h��\u0015,M�tY�3ݩ\u001cO�\"����\\_K���\u0011ፈ.���u,��\u0015� ���?7\u0016o��sn�!�R%�g��\f���P�R%�3@34 �K\\*.��\\*��ƀ̎i����ro�n9\u0006�\\_��;ܼ���u~�)~k�r���;\u001a\u001b��poL-j�s��d��'��:r�7\u0019x\u0015�b��5�o�F\u0002\u0012�I��\u0006��OE�.\u000eo��8B�������&�5��.�|�t����\u001e\fYa5\\]�iJJ♳d�Sm�0D�1\fYQ\u0005Qdx�&��\u0010uDx#��U���X��+�\u001bN�\\\\aK�}!�\\[41LW� ,\\]�2���\u0005uݖF\u0017����q9\\\\�DQ\u001c���f�\u0006��ל �\u001d�AR\fV3�\u0003�f\b�Q��\u0007\\[d\u0016x��9�ނЀ�U��Xne�F{kV;X&>�z݄ҕ.��\u0014�U/�Z͍��|4�o�&�I\\`\\*��3-����7�\\\\����߸�}�\u001aN���l�ef� G��RWE��B\u001f��\\`�\u001ds%\\[\u0005��8�P�r���q-�XLQdd��xJ��<�a�9�\u0001\\]�8QdLS%�p�y��\u001e|~%�a\u0003F�{�d�FN����\u001f1\u001a�{d����s�7�\u0001\\`�3{f\b!�/�8�K����eɗ�I��\u0015� �7@�b��\u0018G�z5�t�+�L\u001cr�j5� \u0017����ӿ\u000f�S��=�\u00186 �\f����a�\u001a�\u0016�T��ę\u0006\u000f�\u0004�hH��\u0006\"�\u0011��u���%\u001e�\"��\u0014���\f�\\*�^P9�� �y-:�l�6|��T�J鮸�\by\u001b�\\]~�+u�����ܶ�G�\f�����a\u001a|�� �Mji�G���#\u0015'a�!��MN��\u0017�\u0006!4n�H\\\\�\u0010�\u001c�\bG���\\*\\*q�(����\u0016Y�r\u001d?\u0014�.I�\u0016�k�,S�gv\u0011ް��\u0014 �\u001d;�#A?����X' �N;@8�\u0005\u001aEy\u00196\u0010�\u001bdʣ^",
                    "idx": "2-7"
                  },
                  {
                    "title": "Asynchronous JavaScript – Callbacks, Promises, and Async/Await Explained",
                    "url": "https://www.freecodecamp.org/news/asynchronous-javascript-explained/",
                    "type": "website-preview",
                    "text": "Promises are a neat way to fix problems brought about by callback hell, in a method known as promise chaining. You can use this method to sequentially get data from multiple endpoints, but with less code and easier methods.. \n\nSearch  Submit your search query\n\n[](https://www.freecodecamp.org/news/)\n\n[Forum](https://forum.freecodecamp.org/) [Donate](https://www.freecodecamp.org/donate/)\n\nJune 20, 2022 / [#async/await](/news/tag/asyncawait/)\n\nAsynchronous JavaScript – Callbacks, Promises, and Async/Await Explained\n========================================================================\n\n \n\nBy Njong Emy\n\nIf you've been learning JavaScript for a while now, then you've probably heard the term \"asynchronous\" before.\n\nThis is because JavaScript is an asynchronous language...but what does that really mean? In this article, I hope to show you that the concept is not as difficult as it sounds.\n\nSynchronous vs Asynchronous\n===========================\n\nBefore we hop into the real deal, let's look at these two words – synchronous and asynchronous.\n\nBy default, JavaScript is a synchronous, single threaded programming language. This means that instructions can only run one after another, and not in parallel. Consider the little code snippet below:\n\n    let a = 1;\n    let b = 2;\n    let sum = a + b;\n    console.log(sum);\n    \n\nThe above code is pretty simple – it sums two numbers and then logs the sum to the browser console. The interpreter executes these instructions one after another in that order until it is done.\n\nBut this method comes along with disadvantages. Say we wanted to fetch some large amount of data from a database and then display it on our interface. When the interpreter reaches the instruction that fetches this data, the rest of the code is blocked from executing until the data has been fetched and returned.\n\nNow you might say that the data to be fetched isn't that large and it won't take any noticeable time. Imagine that you have to fetch data at multiple different points. This delay compounded doesn't sound like something users would want to come across.\n\nLuckily for us, the problems with synchronous JavaScript were addressed by introducing asynchronous JavaScript.\n\nThink of asynchronous code as code that can start now, and finish its execution later. When JavaScript is running asynchronously, the instructions are not necessarily executed one after the other as we saw before.\n\nIn order to properly implement this asynchronous behavior, there are a few different solutions developers has used over the years. Each solution improves upon the previous one, which makes the code more optimized and easier to understand in case it gets complex.\n\nTo further understand the asynchronous nature of JavaScript, we will go through callback functions, promises, and async and await.\n\nWhat are Callbacks in JavaScript?\n=================================\n\nA callback is a function that is passed inside another function, and then called in that function to perform a task.\n\nConfusing? Let's break it down by practically implementing it.\n\n    console.log('fired first');\n    console.log('fired second');\n    \n    setTimeout(()=>{\n        console.log('fired third');\n    },2000);\n    \n    console.log('fired last');\n    \n\nThe snippet above is a small program that logs stuff to the console. But there is something new here. The interpreter will execute the first instruction, then the second, but it will skip over the third and execute the last.\n\nThe `setTimeout` is a JavaScript function that takes two parameters. The first parameter is another function, and the second is the time after which that function should be executed in milliseconds. Now you see the definition of callbacks coming into play.\n\nThe function inside `setTimeout` in this case is required to run after two seconds (2000 milliseconds). Imagine it being carried off to be executed in some separate part of the browser, while the other instructions continue executing. After two seconds, the results of the function are then returned.\n\nThat is why if we run the above snippet in our program, we will get this:\n\n    fired first\n    fired second\n    fired last\n    fired third\n    \n\nYou see that the last instruction is logged before the function in the `setTimeout` returns its result. Say we used this method to fetch data from a database. While the user is waiting for the database call to return results, the flow in execution will not be interrupted.\n\nThis method was very efficient, but only to a certain point. Sometimes, developers have to make multiple calls to different sources in their code. In order to make these calls, callbacks are being nested until they become very hard to read or maintain. This is referred to as **Callback Hell**\n\nTo fix this problem, promises were introduced.\n\nWhat are Promises in JavaScript?\n================================\n\nWe hear people make promises all the time. That cousin of yours who promised to send you free money, a kid promising to not touch the",
                    "idx": "2-8"
                  },
                  {
                    "title": "Asynchronous JavaScript – Callbacks, Promises, And Async/Await ...",
                    "url": "https://expertbeacon.com/asynchronous-javascript-callbacks-promises-and-async-await-explained/",
                    "type": "website-preview",
                    "text": "Asynchronous JavaScript techniques enable non-blocking execution despite external delays. We will compare callbacks, promises and async/await – their evolution driven by the quest for simpler asynchronous code. Consider JavaScript fetching data from an API and displaying it:. ",
                    "idx": "2-9"
                  }
                ]
              }
            }
          ]
        },
        {
          "role": "assistant",
          "content": "Basierend auf der Analyse des Newstextes über asynchrone JavaScript-Programmierung ordne ich ihn folgenden Kategorien zu:\n\n## Kategorisierung und Relevanz-Bewertung:\n\n**programming: Relevanz 8/10**\nDer Text behandelt zentrale Programmierkonzepte in JavaScript (Callbacks, Promises, async/await) und ist für alle JavaScript-Entwickler hochrelevant, da asynchrone Programmierung ein fundamentales Thema ist 【2-0】【2-1】.\n\n**ai: Relevanz 2/10**\nNur indirekt relevant, da moderne KI-Anwendungen oft JavaScript verwenden, aber der Text behandelt keine KI-spezifischen Themen.\n\n**work: Relevanz 6/10**\nSehr relevant für Webentwickler und JavaScript-Programmierer im Arbeitsalltag, da asynchrone Programmierung ein tägliches Werkzeug ist und die Produktivität direkt beeinflusst 【2-2】【2-3】.\n\n**Nicht zutreffende Kategorien:**\n- **databases**: Der Text erwähnt zwar Datenbankoperationen als Beispiel, behandelt aber keine datenbankspezifischen Themen\n- **security**: Keine sicherheitsrelevanten Inhalte\n- **data protection**: Keine datenschutzrelevanten Aspekte  \n- **copyright**: Keine urheberrechtlichen Themen\n\nDer Text ist ein technischer Leitfaden, der verschiedene Ansätze zur asynchronen Programmierung in JavaScript vergleicht und deren Vor- und Nachteile aufzeigt 【2-4】【2-5】. Er richtet sich primär an Entwickler, die ihre JavaScript-Kenntnisse vertiefen möchten.",
          "id": "85d73544-1c33-47bd-a42c-5aec1d6a04da"
        }
      ],
      "formattedResult": [
        [
          {
            "name": "programming",
            "reasoning": "Der Text behandelt zentrale Programmierkonzepte in JavaScript (Callbacks, Promises, async/await) und ist für alle JavaScript-Entwickler hochrelevant, da asynchrone Programmierung ein fundamentales Thema ist.",
            "relevance": 8
          },
          {
            "name": "ai",
            "reasoning": "Nur indirekt relevant, da moderne KI-Anwendungen oft JavaScript verwenden, aber der Text behandelt keine KI-spezifischen Themen.",
            "relevance": 2
          },
          {
            "name": "work",
            "reasoning": "Sehr relevant für Webentwickler und JavaScript-Programmierer im Arbeitsalltag, da asynchrone Programmierung ein tägliches Werkzeug ist und die Produktivität direkt beeinflusst.",
            "relevance": 6
          }
        ]
      ]
    }
  }
}